<!doctype html>
<html>
<head>
<title>imgplay2-</title>
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<script>
/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
if ( !window.requestAnimationFrame ) {
	window.requestAnimationFrame = (function() {
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
			window.setTimeout( callback, 1000 / 60 );
		};
	})();
}
/**
 * OOP class inheritance.
 */
function deriveFrom (child, parent) {
	child.prototype = Object.create(parent.prototype);
	child.prototype.baseclass = parent.prototype;
	child.prototype.constructor = child; // Reset the constructor from parent to child
}
/**
 * String to hex and hex to string.
 */
String.prototype.hexEncode = function () {
	var hex, i;
	var result = "";
	for (i=0; i<this.length; i++) {
		hex = this.charCodeAt(i).toString(16);
		result += ("000"+hex).slice(-4);
	}
	return result;
}
String.prototype.hexDecode = function () {
	var j;
	var hexes = this.match(/.{1,4}/g) || [];
	var back = "";
	for(j = 0; j<hexes.length; j++) {
		back += String.fromCharCode(parseInt(hexes[j], 16));
	}
	return back;
}
function encodeId (id) {
	return id.replace(/[:\.]/g, "$&$&")
		.replace(/[^A-Za-z0-9_:\.]/g, function (match) {
			var c = match.charCodeAt(0);
			if (c < 16)	return ".0" + c.toString(16);
			if (c < 256)	return "." + c.toString(16);
			if (c < 4096)	return ":0" + c.toString(16);
			return ":" + c.toString(16);
		});
}
function decodeId (str) {
	return str.replace(/(^|[^\.])\.([A-Fa-f0-9]{2})/g, function (match, p1, p2) { return p1 + String.fromCharCode(parseInt(p2, 16)); })
		.replace(/(^|[^:]):([A-Fa-f0-9]{4})/g, function (match, p1, p2) { return p1 + String.fromCharCode(parseInt(p2, 16)); })
		.replace(/::|\.\./g, function (match) { return String.fromCharCode(match.charCodeAt(0)); });
}
function jqId ( id ) { return id.replace( /(:|\.|\[|\]|,)/g, "\\$1" ); }
</script>
<style>
	.ui-resizable-handle { cursor: nw-resize; }
	.ui-button { /*float: right;*/ display: inline-block; cursor: pointer; /*margin-bottom: -3px;*/ }
	.ui-right { vertical-align: top; float: right; }

	input[type=checkbox] { width: 8px; height: 8px; }

/*************** round checkbox stuff ***************
	.roundCheckbox input[type=checkbox] { width: 3px; height: 3px; visibility: hidden; margin: 0; }
	.roundCheckbox {
		display: inline-block;
		vertical-align: -4px;
		
		width: 12px;
		height: 12px;
		background: #ddd;
		margin-bottom: -2px;

		border-radius: 100%;
		position: relative;
		-webkit-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox label {
		display: block;
		width: 9px;
		height: 9px;
		border-radius: 100px;

		-webkit-transition: all .5s ease;
		-moz-transition: all .5s ease;
		-o-transition: all .5s ease;
		-ms-transition: all .5s ease;
		transition: all .5s ease;
		cursor: pointer;
		position: absolute;
		top: 2px;
		left: 2px;

		background: #333;

		-webkit-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox input[type=checkbox]:checked + label {
		background: #26ca28;
	}
	.roundCheckbox input[type=checkbox]:disabled + label {
		background: #bbb;
		cursor: default;
	}
*************** end round checkbox ****************/

	/*body { color: #508; }*/

	.contCenter {  text-align: center; /*margin-top: 50%; float: none;*/ }

	.contRightTop { width: 20%; float: right; clear: both; margin: 4px 4px 0px 0px; min-width: 85px; }
	.boxHead { text-align: center; white-space: nowrap; min-width: 85px; }
	#playbackContainer .ui-icon { background-image: url("//code.jquery.com/ui/1.11.4/themes/black-tie/images/ui-icons_ededed_256x240.png"); }

	.contCheckbox { white-space: nowrap; }
	.contCheckbox input[type=checkbox] { /*width: 3px; height: 3px; visibility: hidden; margin: 0;*/ display: none; }
	.contCheckbox label {
		-webkit-transition: all .5s ease;
		-moz-transition: all .5s ease;
		-o-transition: all .5s ease;
		-ms-transition: all .5s ease;
		transition: all .5s ease;
		cursor: pointer;
		color: #333;
	}
	.contCheckbox input[type=checkbox]:checked + label {
		color: #26ca28;
	}
	.contCheckbox input[type=checkbox]:disabled + label {
		color: #bbb;
		cursor: default;
	}

	.dropdown { display: inline-block; }
	.dropdown select { border-width: 0; }	
</style>
</head>
<body>
<object id="img-applet-ie"
  classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
  width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;">
  <param name="archive" value="img-applet.jar">
  <param name="code" value="img_applet.ImgApplet">
  <param name="java_status_events" value="true">
  <!-- <param name="debug" value="yes"> -->
  <comment>
    <embed id="img-applet"
      type="application/x-java-applet"
      width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;" 
      archive="img-applet.jar"
      code="img_applet.ImgApplet"
      pluginspage="http://java.com/download/"
      java_status_events="true" /><!-- 
      debug="yes" -->
  </comment>
</object>
<div id="sign-in-panel">
<div class="container">
<div class="form-inline form-group contCenter">
	<label for="enter-your-name">Please enter your name</label>
	<input class="form-control" type="text" id="enter-your-name" />
	<span class='ui-icon ui-icon-refresh ui-button' title='Enter Your Name' onclick="
		var val = $.trim($('#enter-your-name').val());
		if ($('#enter-your-name').val() !== val)
			$('#enter-your-name').val(val);
		if (val)
		{
			$('#sign-in-panel').css('display', 'none');
			$('#video-chat-panel').css('display', '');
			registerAppletStateHandler();
		}
	"></span>
</div>
</div>
</div>
<div id="video-chat-panel" style="display:none;">
	<div id="deviceContainer" class="contRightTop"></div>
	<div id="playbackContainer" class="contRightTop"></div>
</div>
<script>

// global variables
var applets = [ document.getElementById( 'img-applet' ), document.getElementById( 'img-applet-ie' ) ],
	_applet,
	sn = 0,
	ffmpeg_ids = {},
	devices = {},
	videos = {};

function checkAppletMethod(applet, method) { return applet && (!method || (applet[method] || typeof(applet[method]) === "unknown")); }

function checkApplet(applet, applet_ie, method) { if (!_applet) { if (applet && applet.createFFmpeg) { _applet = applet; } else if (applet_ie && typeof(applet_ie.createFFmpeg) === "unknown") { _applet = applet_ie; } } return checkAppletMethod(_applet, method); }

function registerAppletStateHandler() {
	var READY = 2;
	// register onLoad handler if applet has not loaded yet
	if (checkApplet(applets[0], applets[1])) {
		if (_applet.status < READY)  {
			_applet.onload = onLoadHandler;
		} else if (_applet.status >= READY) {
			// applet has already loaded or there was an error
			onLoadHandler();
		}
	}
}

function createVideoCanvas (container, resizable) {
	var image, videoImage, $videoImageContainer, videoImageContext, last_img = -1;
	function createImage() { return $('<img style="visibility: hidden; display: none;" />').appendTo(container)[0]; }
	image = [ createImage(), createImage() ];
	if (resizable)
		$videoImageContainer = $("<div style='position:absolute;width:0px;height:0px;'></div>").appendTo(container);
	videoImage = $("<canvas width='0' height='0'></canvas>").appendTo($videoImageContainer || container)[0];
	// create '2d' context; background color if no video present
	videoImageContext = videoImage.getContext( '2d' );
	videoImageContext.fillStyle = '#005337';
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );				
	// assign image elements onload handler
	var setDimensions = true, curImageIndex;
	image[0].onload = image[1].onload = function() {
		if (setDimensions) {
			setDimensions = false;
			videoImage.width = this.width;
			videoImage.height = this.height;
			if ($videoImageContainer) {
				$videoImageContainer.width(this.width);
				$videoImageContainer.height(this.height);
			}
			if (resizable)
				$videoImageContainer.draggable().resizable({
					aspectRatio: this.width / this.height,
					resize: function(event, ui) {
						image[0].width = image[1].width = videoImage.width = ui.size.width;
						image[0].height = image[1].height = videoImage.height = ui.size.height;
						videoImageContext.drawImage( image[curImageIndex], 0, 0, videoImage.width, videoImage.height );
					}
				});
		}
		curImageIndex = this === image[0] ? 0 : 1;
		videoImageContext.drawImage( this, 0, 0, videoImage.width, videoImage.height );
	};
	return {
		drawUri:	function (uri) { image[last_img = (last_img + 1) % 2].src = uri; },
		destroy:	function () { ($videoImageContainer || $(videoImage)).add(image[0], image[1]).remove(); }
	};
}

function checkboxClick(checkbox) {
	_applet[checkbox.checked?'play':'stopPlayback'](ffmpeg_ids[checkbox.id]);
}
function findByFFmpegId(ffmpeg_id) {
	for (var key in ffmpeg_ids)
		if (ffmpeg_ids[key] === ffmpeg_id)
			return key;
}
function checkboxCallback(ffmpeg_id, playing) {
	var key = findByFFmpegId(ffmpeg_id);
	if (key)
		document.getElementById(key).checked = playing;
}

function removeFFmpeg(key) {
	if (ffmpeg_ids[key]) {
		_applet.stopPlayback(ffmpeg_ids[key]);
		_applet.removeFFmpegById(ffmpeg_ids[key]);
		delete ffmpeg_ids[key];
		delete devices[key];
		if (videos[key])
			videos[key].destroy();
		delete videos[key];
	}
}

function recreateFFmpeg(key, callback, param_arr) {
	var playing = false;
	if (ffmpeg_ids[key]) {
		playing = _applet.isPlaying(ffmpeg_ids[key]);
		removeFFmpeg(key);
	}
	ffmpeg_ids[key] = _applet.createFFmpegId(callback, param_arr);
	if (playing)
		_applet.play(ffmpeg_ids[key]);
}

var _op = {
	capture_video: 1,
	playback_video: 2,
	capture_audio: 3,
	playback_audio: 4,
	list_devices: 5,
	list_options: 6,
	capture_screen: 7
};

function renewFFmpeg(op, key, p1, p2) {
	switch (op) {

	case _op.capture_video: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-r', '25',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'video=' + p1,		// video device, e.g. "Logitech QuickCam E3500"
			'ffmpeg-c:v', 'libx264',
			'ffmpeg-preset', 'ultrafast',
			'ffmpeg-tune', 'zerolatency',
			'ffmpeg-pix_fmt', 'yuv420p',
			'ffmpeg-g', '50',
			'ffmpeg-an', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_video: recreateFFmpeg( key, 'checkboxCallback', [
			//"ffmpeg-re", "",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v",
			//"ffmpeg-i", "rtmp://europaplus.cdnvideo.ru:1935/europaplus-live/eptv_main.sdp",
			//"ffmpeg-i", "rtmp://85.132.78.6:1935/live/muztv.stream",
			//"ffmpeg-i", "http://83.139.104.101/Content/HLS/Live/Channel(Sk_1)/index.m3u8",
			//"ffmpeg-map", "0:6",
			"ffmpeg-c:v", "mjpeg",
			"ffmpeg-q:v", "0.0",
 /* ‘-vsync parameter’
    Video sync method. For compatibility reasons old values can be specified as numbers. 
    Newly added values will have to be specified as strings always.
    ‘0, passthrough’ - Each frame is passed with its timestamp from the demuxer to the muxer. 
    ‘1, cfr’ - Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. 
    ‘2, vfr’ - Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. 
    ‘drop’ - As passthrough but destroys all timestamps, making the muxer generate fresh timestamps based on frame-rate. 
    ‘-1, auto’ - Chooses between 1 and 2 depending on muxer capabilities. This is the default method.
  */
			"ffmpeg-vsync", "0",
			"ffmpeg-f:o", "mjpeg",
			"ffmpeg-an", "",
			//"ffmpeg-muxpreload", "10",
			//"ffmpeg-muxdelay", "10",
			//"ffmpeg-loglevel", "warning",
			"drop-unused-frames", "yes",
			"debug", "yes",
			//"debug-ffmpeg", "yes",
		] ); videos[key] = createVideoCanvas(p2, true); break; // p2 - container's selector or jQuery object

	case _op.capture_audio: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-audio_buffer_size', '50',
			'ffmpeg-i', 'audio=' + p1,		// audio device, e.g. "Microphone (USB Audio Device)"
			'ffmpeg-c:a', 'libmp3lame',
			'ffmpeg-async', '1',
			'ffmpeg-vn', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_audio: recreateFFmpeg( key, 'checkboxCallback', [
			"ffmpeg-re", "no",
			"ffmpeg-analyzeduration", "1000",
			"ffmpeg-rtmp_buffer", "0",
			"ffmpeg-rtmp_live", "live",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			//"ffmpeg-c:a", "libmp3lame",
			//"ffmpeg-f:o", "mp3",
			//"mp3-frames-per-chunk", "1",
			"ffmpeg-f:o", "wav",
			"ffmpeg-vn", "",
			//"wav-audio-line-buffer-size", "2200",
			"wav-intermediate-buffer-size", "32",
			"debug", "yes",
			//"debug-ffmpeg", "yes",
		] ); break;

	case _op.capture_screen: recreateFFmpeg( key, 'checkboxCallback', [
			//'ffmpeg-r', '25',
			'ffmpeg-f:i', 'gdigrab',
			'ffmpeg-video_size', '800x600',
			'ffmpeg-show_region', '1',
			'ffmpeg-i', 'desktop',
			'ffmpeg-c:v', 'libx264',
			'ffmpeg-preset', 'ultrafast',
			'ffmpeg-tune', 'zerolatency',
			'ffmpeg-pix_fmt', 'yuv420p',
			'ffmpeg-g', '50',
			'ffmpeg-an', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/s"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); break;
	}
}

function callFFmpeg(op, p1) {
	var _ffmpeg_id, defer = $.Deferred().always(function () {
		if (_ffmpeg_id) {
			_applet.removeFFmpegById(_ffmpeg_id);
			//alert("remove: " + _ffmpeg_id);
		}
	});
	window.dataCallback = function (ffmpeg_id, playing) {
		if (!playing) {
			defer.resolve(_applet.getStderrData(ffmpeg_id));
			//alert("resolve: " + ffmpeg_id);
		}
	};
	switch (op) {

	case _op.list_devices: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_devices', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'dummy',
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;

	case _op.list_options: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_options', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', p1,			// device, e.g. 'video=Logitech QuickCam Communicate STX', or 'audio=Logitech Mic (Communicate STX)'
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;
	}
	if (_ffmpeg_id) {
		_applet.play(_ffmpeg_id);
	}
	return defer.promise();
}

function getMyName() { return $('#enter-your-name').val(); }

function getMyRtmpAppName(deviceType) { return getMyName() + '|' + deviceType; }

function getStreamInfo(rtmpAppName) { var p = rtmpAppName.lastIndexOf("|"); return { name: rtmpAppName.substring(0, p > -1 ? p : rtmpAppName.length), deviceType: p > -1 ? rtmpAppName.substring(p + 1) : "" }; }

function deviceTypeOrder(a) { return a === "audio" ? 1 : a === "video" ? 2 : a === "screen" ? 3 : 101; }

function orderToDeviceType(n) { return n == 1 ? "audio" : n == 2 ? "video" : n == 3 ? "screen" : "unknown"; }

function deviceToStreamType(a) { return a === "audio" ? "audio" : a === "video" ? "video" : a === "screen" ? "video" : "video"; }

function onLoadHandler() {
	// event handler for ready state
	var rtmp_hostname = window.location.hash && window.location.hash.length > 7 ? window.location.hash.substring(1) : window.location.hostname;
	function getRtmpUrl(rtmp_app) { return 'rtmp://' + rtmp_hostname + '/rtmp/' + encodeURIComponent(rtmp_app); }
	// FFmpeg UI functions
	function keyFromNames(deviceType, opName, name) { return (opName || "capture") + "-" + encodeId(name || "my") + "-" + deviceType; }
	function namesFromKey(key) { var tmp = key.split('-'); return { opName: tmp[0], name: decodeId(tmp[1]), deviceType: tmp[2] }; }
	function getCheckeds() { var checkeds = {}; for (var key in ffmpeg_ids) checkeds[key] = $("#" + jqId(key)).is(":checked"); return checkeds; }
	function create$ffmpegUi(deviceType, checkeds, opName, name) {
		if (!checkeds) checkeds = {};
		var key = keyFromNames(deviceType, opName, name), 
			icon = '<i class="fa fa-' + (deviceType==='audio'?'microphone':deviceType==='video'?'video-camera':deviceType==='screen'?'desktop':'bug') + '"></i>';
		return $(
			'<span class="contCheckbox">' +
				'<span> </span>' +
				//'<label for="' + key + '">' + icon + '</label>' +
				//'<span> </span>' +
				//'<div class="roundCheckbox">' +
					'<input id="' + key + '" type="checkbox" onclick="checkboxClick(this)"' + (checkeds[key] ? ' checked="checked"' : '') + ' />' +
					//'<label for="' + key + '">' + '</label>' +
				//'</div>' +
				'<label for="' + key + '">' + icon + '</label>' +
				//'<span>&nbsp;</span>' +
			'</span>');
	}
	function listDevices () {
		$("#deviceContainer select").css("visibility", "hidden");
		callFFmpeg(_op.list_devices).then(function (res) {
			// DeviceType class
			function DeviceType(deviceType) {
				this.deviceType = deviceType;
				this.$ffmpegUi = create$ffmpegUi(deviceType, checkeds);
			}
			DeviceType.prototype.appendTo = function(container) { this.$ffmpegUi.appendTo(container); return this; };
			DeviceType.prototype.renew = function() {
				var key = keyFromNames(this.deviceType);
				if (!checkeds[key])
					renewFFmpeg(_op["capture_" + this.deviceType], key, getRtmpUrl(getMyRtmpAppName(this.deviceType)));
			};
			// DirectShowDevice class
			deriveFrom(DirectShowDevice, DeviceType);
			function DirectShowDevice(deviceType) {
				this.baseclass.constructor.call(this, deviceType);
				var key = keyFromNames(deviceType);
				this.$dropdown = $(
					'<div class="dropdown">' +
						'<a id="'+ key + '-trigger" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">' +
							'<span class="caret"></span>' +
						'</a>' +
						'<div class="dropdown-menu pull-right" aria-labelledby="'+ key + '-trigger">' +
							'<select></select>' +
						'</div>' +
					'</div>');
				var self = this;
				this.$select = DirectShowDevice.$select = this.$dropdown.find("select").change(function () {
					self.updateUi(self.setDeviceName($(this).val()));
				});
				this.$dropdown.insertAfter(this.$ffmpegUi.find("label"));
			}
			DirectShowDevice.prototype.renew = function() {
				this.updateUi(this.restoreDeviceName());
				if (this.$select.find("option").filter(function () { return this.value; }).length < 2)
					this.$dropdown.css("visibility", "hidden");
			};
			DirectShowDevice.prototype.updateUi = function(deviceName) {
				var key = keyFromNames(this.deviceType);
				var $checkbox = $("#" + jqId(key)).prop("disabled", !deviceName);
				if (!deviceName)
					$checkbox.prop("checked", false);
				var $label = $("label[for=" + jqId(key) + "]");
				$label.attr("title", deviceName);
			}
			DirectShowDevice.prototype.renewFFmpeg = function(key, val) { renewFFmpeg(_op["capture_" + this.deviceType], key, val, getRtmpUrl(getMyRtmpAppName(this.deviceType))); }
			DirectShowDevice.prototype.restoreDeviceName = function() {
				var key = keyFromNames(this.deviceType), deviceName = devices[key], val;
				if (deviceName) {
					if (this.$select.find("option").filter(function () { return this.value === deviceName; }).length > 0) {
						this.$select.val(deviceName);
					}
					val = this.$select.val();
					if (val) {
						if (deviceName !== val)
							this.renewFFmpeg(key, val);
					} else {
						removeFFmpeg(key);
					}
				} else if (val = this.$select.val()) {
					this.renewFFmpeg(key, val);
				}
				return val || "";
			}
			DirectShowDevice.prototype.setDeviceName = function(val) {
				var key = keyFromNames(this.deviceType), deviceName = devices[key];
				if (val) {
					if (deviceName !== val)
						this.renewFFmpeg(key, val);
				} else if (deviceName) {
					removeFFmpeg(key);
				}
				return val || "";
			}
			
			// recreate UI
			var checkeds = getCheckeds();
			$("#deviceContainer").empty();
			var deviceTypes = [];
			// parse DirectShow output
			var re = /\[\s*dshow\s*@\s*[a-fA-F0-9]+\s*\]\s*"?(.*?)"?\s*\r?\n/ig, match, arr = [];
			while ((match = re.exec(res)) !== null) {
				arr.push(match[1]);
			}
			re = /^\s*Direct\s*Show\s*(video|audio)\s*devices\s*$/i;
			var re1 = /^\s*Could\s*not\s*enumerate\s*(video|audio)\s*devices\.?\s*$/i;
			// add DirectShow devices
			for (var i in arr) {
				if (re.test(arr[i])) {
					var deviceType = re.exec(arr[i])[1].toLowerCase();
					deviceTypes.push(new DirectShowDevice(deviceType));
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo(DirectShowDevice.$select);
				} else if (re1.test(arr[i])) {
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo(DirectShowDevice.$select);
				} else {
					$("<option></option>").attr("value", arr[i]).text(arr[i]).appendTo(DirectShowDevice.$select);
				}
			}
			// add screen grab
			deviceTypes.push(new DeviceType("screen"));
			// sort deviceTypes
			deviceTypes.sort(function(a, b) {
				return deviceTypeOrder(a.deviceType) - deviceTypeOrder(b.deviceType);
			});
			var $head = $("<div class='boxHead' style='background-color:cyan;'>Capture</div>").appendTo("#deviceContainer");
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button ui-right' title='Refresh Audio/Video Devices'></span>").appendTo($head).click(listDevices);
			// try to restore current devices
			var $line = $("<div style='text-align:right;'><span style='float:left;font-weight:bold;'>" + getMyName() + "</span></div>").appendTo("#deviceContainer");
			for (var i = 0; i < deviceTypes.length; i++) {
				deviceTypes[i].appendTo($line).renew();
			}
		});
	}
	function listStreams () {
		$.ajax({
			url: 'http://' + rtmp_hostname + '/rtmp/stat',
			cache: false,
			dataType: "xml"
		}).then(function (data) {
			var $xml = $(data), $streams = $xml.find("rtmp > server > application:has(> name)").filter(function () { return $(this).find("> name").text() === "rtmp"; }).find("> live > stream");
			function getStreamType($stream) {
				var $video = $stream.find("> meta > video"), $audio;
				return parseFloat($video.find("> width").text()) > 0 && parseFloat($video.find("> height").text()) > 0 ? "video" : $stream.find("> meta > audio").has("*") ? "audio" : "unknown";
			}
			var checkeds = getCheckeds(), opName = "play";
			$("#playbackContainer").empty();
			for (var key in ffmpeg_ids) {
				var names = namesFromKey(key);
				if (names.opName === "play" && !checkeds[key]) {
					removeFFmpeg(key);
				}
			}
			var rtmpStreams = [];
			$streams.each(function (i, e) {
				var $e = $(e), rtmp_app = $e.find("name").text(), info = getStreamInfo(rtmp_app);
				rtmpStreams.push({ rtmp_app: rtmp_app, streamType: getStreamType($e), deviceType: info.deviceType, name: info.name });
			});
			// sort rtmpStreams
			rtmpStreams.sort(function(a, b) {
				return a.name > b.name ? 1 : a.name < b.name ? -1 : deviceTypeOrder(a.deviceType) - deviceTypeOrder(b.deviceType);
			});
			// add header
			var $head = $("<div class='boxHead' style='background-color:magenta;color:white;'>Playback</div>").appendTo("#playbackContainer");
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button ui-right' title='Refresh Audio/Video Streams'></span>").appendTo($head).click(listStreams);
			var name = "", $line, cnt;
			for (var i = 0; i < rtmpStreams.length; i++) {
				var rtmpStream = rtmpStreams[i];
				if (name !== rtmpStream.name) {
					name = rtmpStream.name;
					$line = $("<div style='text-align:right;'><span style='float:left;font-weight:bold;'>" + name + "</span></div>").appendTo("#playbackContainer");
					cnt = 1;
				}
				// add missing devices
				var deviceOrder = deviceTypeOrder(rtmpStream.deviceType), deviceType = orderToDeviceType(cnt);
				if (deviceOrder < 100) {
					if (deviceOrder > cnt) {
						rtmpStreams.splice(i, 0, rtmpStream = { rtmp_app: name + '|' + deviceType, streamType: deviceToStreamType(deviceType), deviceType: deviceType, name: name });
					}
					cnt++;
				}
				create$ffmpegUi(rtmpStream.deviceType, checkeds, "play", name).css("margin-left", "10px").appendTo($line);
				var key = keyFromNames(rtmpStream.deviceType, "play", name);
				if (!checkeds[key]) {
					renewFFmpeg(_op["playback_" + rtmpStream.streamType], key, getRtmpUrl(rtmpStream.rtmp_app), "#video-chat-panel");
				}
			}
		}, function (error) {
			var err = error;
		});
	}
	listDevices();
	listStreams();
}

// start the loop				
animate();

function animate() {
	requestAnimationFrame( animate );
	render();
}

function render() {
	for (var key in videos) {
		if (ffmpeg_ids[key] && (_applet.getSN || typeof(_applet.getSN) === "unknown")) {
			var sn_ = _applet.getSN(ffmpeg_ids[key]);
			if ( sn_ != sn && sn_ > 0 ) {
				sn = sn_;
				var dataURI = _applet.getDataURI(ffmpeg_ids[key]);
				// drop frames accumulated in the queue
/*
				while (_applet.getSN(ffmpeg_ids[key]) > sn) {
					console.log("dropped frame # " + sn);
					sn = _applet.getSN(ffmpeg_ids[key]);
					dataURI = _applet.getDataURI(ffmpeg_ids[key]);
				}
*/ // we do it in the applet now when drop-unused-frames="yes"
				// assign image src
				videos[key].drawUri(dataURI);
			}
		}
	}
}

$( document ).on( "click", ".dropdown-menu select", function() {
	event.stopPropagation();
});

$(function () {
	function resize() { $('.contCenter').each(function () { var $this = $(this); $this.css('margin-top', ($(document).height() - $this.height()) / 2); }); }
	$(window).resize(resize);
	resize();
});

</script>
</body>
</html>
