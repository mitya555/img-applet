<!doctype html>
<html>
<head>
<title>imgplay2-</title>
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script>
/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
if ( !window.requestAnimationFrame ) {
	window.requestAnimationFrame = (function() {
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
			window.setTimeout( callback, 1000 / 60 );
		};
	})();
}
/**
 * OOP class inheritance.
 */
function deriveFrom (child, parent) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child; // Reset the constructor from parent to child
}
</script>
<style>
	.ui-resizable-handle { cursor: nw-resize; }
	.ui-button { /*float: right;*/ display: inline-block; cursor: pointer; /*margin-bottom: -3px;*/ }
	.ui-right { vertical-align: top; float: right; }
	input[type=checkbox] { width: 8px; height: 8px; }
	.roundCheckbox input[type=checkbox] { width: 3px; height: 3px; visibility: hidden; margin: 0; }
	.roundCheckbox {
		display: inline-block;
		vertical-align: -4px;
		
		width: 12px;
		height: 12px;
		background: #ddd;
		/*margin: 20px 90px;*/
		margin-bottom: -2px;

		border-radius: 100%;
		position: relative;
		-webkit-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox label {
		display: block;
		width: 9px;
		height: 9px;
		border-radius: 100px;

		-webkit-transition: all .5s ease;
		-moz-transition: all .5s ease;
		-o-transition: all .5s ease;
		-ms-transition: all .5s ease;
		transition: all .5s ease;
		cursor: pointer;
		position: absolute;
		top: 2px;
		left: 2px;
		/*z-index: 1;*/

		background: #333;

		-webkit-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox input[type=checkbox]:checked + label {
		background: #26ca28;
	}
	.roundCheckbox input[type=checkbox]:disabled + label {
		background: #bbb;
		cursor: default;
	}
	body { color: #508; }
</style>
</head>
<body>
<object id="img-applet-ie"
  classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
  width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;">
  <param name="archive" value="img-applet.jar">
  <param name="code" value="img_applet.ImgApplet">
  <param name="java_status_events" value="true">
  <!-- <param name="debug" value="yes"> -->
  <comment>
    <embed id="img-applet"
      type="application/x-java-applet"
      width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;" 
      archive="img-applet.jar"
      code="img_applet.ImgApplet"
      pluginspage="http://java.com/download/"
      java_status_events="true" /><!-- 
      debug="yes" -->
  </comment>
</object>
<div id="sign-in-panel">
	<label for="enter-your-name">Please enter your name</label>
	<input type="text" id="enter-your-name" />
	<span class='ui-icon ui-icon-refresh ui-button' title='Enter Your Name' onclick="
		var val = $.trim($('#enter-your-name').val());
		if ($('#enter-your-name').val() !== val)
			$('#enter-your-name').val(val);
		if (val)
		{
			$('#sign-in-panel').css('display', 'none');
			$('#video-chat-panel').css('display', '');
			registerAppletStateHandler();
		}
	"></span>
</div>
<div id="video-chat-panel" style="display:none;">
	<div id="deviceContainer"></div>
	<div id="playbackContainer"></div>
</div>
<script>

// global variables
var applets = [ document.getElementById( 'img-applet' ), document.getElementById( 'img-applet-ie' ) ],
	_applet,
	sn = 0,
	ffmpeg_ids = {},
	devices = {},
	videos = {};

function checkAppletMethod(applet, method) { return applet && (!method || (applet[method] || typeof(applet[method]) === "unknown")); }

function checkApplet(applet, applet_ie, method) { if (!_applet) { if (applet && applet.createFFmpeg) { _applet = applet; } else if (applet_ie && typeof(applet_ie.createFFmpeg) === "unknown") { _applet = applet_ie; } } return checkAppletMethod(_applet, method); }

function registerAppletStateHandler() {
	var READY = 2;
	// register onLoad handler if applet has not loaded yet
	if (checkApplet(applets[0], applets[1])) {
		if (_applet.status < READY)  {
			_applet.onload = onLoadHandler;
		} else if (_applet.status >= READY) {
			// applet has already loaded or there was an error
			onLoadHandler();
		}
	}
}

function createVideoCanvas (container, resizable) {
	var image, videoImage, $videoImageContainer, videoImageContext, last_img = -1;
	function createImage() { return $('<img style="visibility: hidden; display: none;" />').appendTo(container)[0]; }
	image = [ createImage(), createImage() ];
	if (resizable)
		$videoImageContainer = $("<div style='position:absolute;width:0px;height:0px;'></div>").appendTo(container);
	videoImage = $("<canvas width='0' height='0'></canvas>").appendTo($videoImageContainer || container)[0];
	// create '2d' context; background color if no video present
	videoImageContext = videoImage.getContext( '2d' );
	videoImageContext.fillStyle = '#005337';
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );				
	// assign image elements onload handler
	var setDimensions = true, curImageIndex;
	image[0].onload = image[1].onload = function() {
		if (setDimensions) {
			setDimensions = false;
			videoImage.width = this.width;
			videoImage.height = this.height;
			if ($videoImageContainer) {
				$videoImageContainer.width(this.width);
				$videoImageContainer.height(this.height);
			}
			if (resizable)
				$videoImageContainer.draggable().resizable({
					aspectRatio: this.width / this.height,
					resize: function(event, ui) {
						image[0].width = image[1].width = videoImage.width = ui.size.width;
						image[0].height = image[1].height = videoImage.height = ui.size.height;
						videoImageContext.drawImage( image[curImageIndex], 0, 0, videoImage.width, videoImage.height );
					}
				});
		}
		curImageIndex = this === image[0] ? 0 : 1;
		videoImageContext.drawImage( this, 0, 0, videoImage.width, videoImage.height );
	};
	return {
		drawUri:	function (uri) { image[last_img = (last_img + 1) % 2].src = uri; },
		destroy:	function () { ($videoImageContainer || $(videoImage)).add(image[0], image[1]).remove(); }
	};
}

function checkboxClick(checkbox) {
	_applet[checkbox.checked?'play':'stopPlayback'](ffmpeg_ids[checkbox.id]);
}
function findByFFmpegId(ffmpeg_id) {
	for (var key in ffmpeg_ids)
		if (ffmpeg_ids[key] === ffmpeg_id)
			return key;
}
function checkboxCallback(ffmpeg_id, playing) {
	var key = findByFFmpegId(ffmpeg_id);
	if (key)
		document.getElementById(key).checked = playing;
}

function removeFFmpeg(key) {
	if (ffmpeg_ids[key]) {
		_applet.stopPlayback(ffmpeg_ids[key]);
		_applet.removeFFmpegById(ffmpeg_ids[key]);
		delete ffmpeg_ids[key];
		delete devices[key];
		if (videos[key])
			videos[key].destroy();
		delete videos[key];
	}
}

function recreateFFmpeg(key, callback, param_arr) {
	var playing = false;
	if (ffmpeg_ids[key]) {
		playing = _applet.isPlaying(ffmpeg_ids[key]);
		removeFFmpeg(key);
	}
	ffmpeg_ids[key] = _applet.createFFmpegId(callback, param_arr);
	if (playing)
		_applet.play(ffmpeg_ids[key]);
}

var _op = {
	capture_video: 1,
	playback_video: 2,
	capture_audio: 3,
	playback_audio: 4,
	list_devices: 5,
	list_options: 6,
	capture_screen: 7
};

function renewFFmpeg(op, key, p1, p2) {
	switch (op) {

	case _op.capture_video: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-r', '25',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'video=' + p1,		// video device, e.g. "Logitech QuickCam E3500"
			'ffmpeg-c:v', 'libx264',
			'ffmpeg-preset', 'ultrafast',
			'ffmpeg-tune', 'zerolatency',
			'ffmpeg-pix_fmt', 'yuv420p',
			'ffmpeg-g', '50',
			'ffmpeg-an', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_video: recreateFFmpeg( key, 'checkboxCallback', [
			//"ffmpeg-re", "",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v",
			//"ffmpeg-i", "rtmp://europaplus.cdnvideo.ru:1935/europaplus-live/eptv_main.sdp",
			//"ffmpeg-i", "rtmp://85.132.78.6:1935/live/muztv.stream",
			//"ffmpeg-i", "http://83.139.104.101/Content/HLS/Live/Channel(Sk_1)/index.m3u8",
			//"ffmpeg-map", "0:6",
			"ffmpeg-c:v", "mjpeg",
			"ffmpeg-q:v", "0.0",
 /* ‘-vsync parameter’
    Video sync method. For compatibility reasons old values can be specified as numbers. 
    Newly added values will have to be specified as strings always.
    ‘0, passthrough’ - Each frame is passed with its timestamp from the demuxer to the muxer. 
    ‘1, cfr’ - Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. 
    ‘2, vfr’ - Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. 
    ‘drop’ - As passthrough but destroys all timestamps, making the muxer generate fresh timestamps based on frame-rate. 
    ‘-1, auto’ - Chooses between 1 and 2 depending on muxer capabilities. This is the default method.
  */
			"ffmpeg-vsync", "0",
			"ffmpeg-f:o", "mjpeg",
			"ffmpeg-an", "",
			//"ffmpeg-muxpreload", "10",
			//"ffmpeg-muxdelay", "10",
			//"ffmpeg-loglevel", "warning",
			"drop-unused-frames", "yes",
			"debug", "yes",
			//"debug-ffmpeg", "yes",
		] ); videos[key] = createVideoCanvas(p2, true); break; // p2 - container's selector or jQuery object

	case _op.capture_audio: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-audio_buffer_size', '50',
			'ffmpeg-i', 'audio=' + p1,		// audio device, e.g. "Microphone (USB Audio Device)"
			'ffmpeg-c:a', 'libmp3lame',
			'ffmpeg-async', '1',
			'ffmpeg-vn', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_audio: recreateFFmpeg( key, 'checkboxCallback', [
			"ffmpeg-re", "no",
			"ffmpeg-analyzeduration", "1000",
			"ffmpeg-rtmp_buffer", "0",
			"ffmpeg-rtmp_live", "live",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			//"ffmpeg-c:a", "libmp3lame",
			//"ffmpeg-f:o", "mp3",
			//"mp3-frames-per-chunk", "1",
			"ffmpeg-f:o", "wav",
			"ffmpeg-vn", "",
			//"wav-audio-line-buffer-size", "2200",
			"wav-intermediate-buffer-size", "32",
			"debug", "yes",
			//"debug-ffmpeg", "yes",
		] ); break;

	case _op.capture_screen: recreateFFmpeg( key, 'checkboxCallback', [
			//'ffmpeg-r', '25',
			'ffmpeg-f:i', 'gdigrab',
			'ffmpeg-video_size', '800x600',
			'ffmpeg-show_region', '1',
			'ffmpeg-i', 'desktop',
			'ffmpeg-c:v', 'libx264',
			'ffmpeg-preset', 'ultrafast',
			'ffmpeg-tune', 'zerolatency',
			'ffmpeg-pix_fmt', 'yuv420p',
			'ffmpeg-g', '50',
			'ffmpeg-an', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/s"
			'debug', 'yes',
			//'debug-ffmpeg', 'yes',
		] ); break;
	}
}

function callFFmpeg(op, p1) {
	var _ffmpeg_id, defer = $.Deferred().always(function () {
		if (_ffmpeg_id) {
			_applet.removeFFmpegById(_ffmpeg_id);
			//alert("remove: " + _ffmpeg_id);
		}
	});
	window.dataCallback = function (ffmpeg_id, playing) {
		if (!playing) {
			defer.resolve(_applet.getStderrData(ffmpeg_id));
			//alert("resolve: " + ffmpeg_id);
		}
	};
	switch (op) {

	case _op.list_devices: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_devices', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'dummy',
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;

	case _op.list_options: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_options', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', p1,			// device, e.g. 'video=Logitech QuickCam Communicate STX', or 'audio=Logitech Mic (Communicate STX)'
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;
	}
	if (_ffmpeg_id) {
		_applet.play(_ffmpeg_id);
	}
	return defer.promise();
}

function onLoadHandler() {
	// event handler for ready state
	var rtmp_hostname = window.location.hash && window.location.hash.length > 7 ? window.location.hash.substring(1) : window.location.hostname;
	// FFmpeg UI functions
	function keyFromNames(deviceTypeName, opName, name) { return (opName || "capture") + "-" + (name || "my") + "-" + deviceTypeName; }
	function namesFromKey(key) { var tmp = key.split('-'); return { opName: tmp[0], name: tmp[1], deviceTypeName: tmp[2] }; }
	function getCheckeds() { var checkeds = {}; for (var key in ffmpeg_ids) checkeds[key] = $("#" + key).is(":checked"); return checkeds; }
	function create$ffmpegUi(deviceTypeName, checkeds, opName, name) {
		if (!checkeds) checkeds = {};
		var key = keyFromNames(deviceTypeName, opName, name), 
			icon = '<i class="fa fa-' + (deviceTypeName=='audio'?'microphone':deviceTypeName=='video'?'video-camera':deviceTypeName=='screen'?'desktop':'bug') +
			'" style="cursor:default;/*color:green;*/vertical-align:middle;"></i>';
		return $('<span> </span>' +
			'<label for="' + key + '">' + (name ? "<b>" + name + "</b>'s " : "") +
			//deviceTypeName +
			icon +
			'</label>' +
			'<span> </span>' +
			'<div class="roundCheckbox">' +
			'<input id="' + key + '" type="checkbox" onclick="checkboxClick(this)"' + (checkeds[key] ? ' checked="checked"' : '') + ' />' +
			'<label for="' + key + '">' + /*icon +*/ '</label>' +
			'</div>' +
			'<span>&nbsp;</span>');
	}
	var listDevices = function () {
		$("#deviceContainer select").css("visibility", "hidden");
		callFFmpeg(_op.list_devices).then(function (res) {
			// parse output
			var re = /\[\s*dshow\s*@\s*[a-fA-F0-9]+\s*\]\s*"?(.*?)"?\s*\r?\n/ig, match, arr = [];
			while ((match = re.exec(res)) !== null) {
				arr.push(match[1]);
			}
			// recreate dropdowns
			var checkeds = getCheckeds();
			$("#deviceContainer").empty();
			re = /^\s*Direct\s*Show\s*(video|audio)\s*devices\s*$/i;
			var re1 = /^\s*Could\s*not\s*enumerate\s*(video|audio)\s*devices\.?\s*$/i;
			var deviceTypes = [];
			function DeviceType(deviceType) {
				this.deviceType = deviceType;
				this.$ffmpegUi = create$ffmpegUi(deviceType, checkeds);
			}
			DeviceType.prototype.appendTo = function(container) { this.$ffmpegUi.appendTo(container); if (this.$select) this.$select.appendTo(container); return this; };
			DeviceType.prototype.renew = function() {
				var key = keyFromNames(this.deviceType);
				if (!checkeds[key])
					renewFFmpeg(_op["capture_" + this.deviceType], key, 'rtmp://' + rtmp_hostname + '/rtmp/' + getRtmpAppName(this.deviceType));
			};
			function DirectShowDeviceType(deviceType) {
				DeviceType.apply(this, arguments);
				this.$select = DirectShowDeviceType.$select = $("<select style='border-width:0;'></select>").change(function () {
					updateDirectShowDeviceUi(deviceType, setDirectShowDevice(deviceType, $(this).val(), rtmp_hostname));
				});
			}
			deriveFrom(DirectShowDeviceType, DeviceType);
			DirectShowDeviceType.prototype.renew = function() {
				updateDirectShowDeviceUi(this.deviceType, restoreDirectShowDevice(this.deviceType, this.$select, rtmp_hostname));
				if (this.$select.find("option").filter(function () { return this.value; }).length < 2)
					this.$select.css("display", "none");
			};
			for (var i in arr) {
				if (re.test(arr[i])) {
					var deviceType = re.exec(arr[i])[1].toLowerCase();
					deviceTypes.push(new DirectShowDeviceType(deviceType));
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo(DirectShowDeviceType.$select);
				} else if (re1.test(arr[i])) {
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo(DirectShowDeviceType.$select);
				} else {
					$("<option></option>").attr("value", arr[i]).text(arr[i]).appendTo(DirectShowDeviceType.$select);
				}
			}
			// add screen grab
			deviceTypes.push(new DeviceType("screen"));
			// sort deviceTypes
			deviceTypes.sort(function(a, b) {
				function deviceTypeOrder(a) { return a==="audio"?1:a==="video"?2:a==="screen"?3:4; }
				return deviceTypeOrder(a.deviceType) - deviceTypeOrder(b.deviceType);
			});
			// try to restore current devices
			for (var i = 0; i < deviceTypes.length; i++) {
				deviceTypes[i].appendTo("#deviceContainer").renew();
			}
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button ui-right' title='Refresh Audio/Video Devices'></span>").appendTo("#deviceContainer").click(listDevices);
		});
	}, listStreams = function () {
		$.ajax({
			url: 'http://' + rtmp_hostname + '/rtmp/stat',
			cache: false,
			dataType: "xml"
		}).then(function (data) {
			var $xml = $(data), $streams = $xml.find("rtmp > server > application:has(> name)").filter(function () { return $(this).find("> name").text() === "rtmp"; }).find("> live > stream");
			function getDeviceType($stream) {
				var $video = $stream.find("> meta > video"), $audio;
				return parseFloat($video.find("> width").text()) > 0 && parseFloat($video.find("> height").text()) > 0 ? "video" : $stream.find("> meta > audio").has("*") ? "audio" : "unknown";
			}
			var checkeds = getCheckeds(), opName = "play";
			$("#playbackContainer").empty();
			for (var key in ffmpeg_ids) {
				var names = namesFromKey(key);
				if (names.opName === "play" && !checkeds[key]) {
					removeFFmpeg(key);
				}
			}
			$streams.each(function (i, e) {
				var $e = $(e), deviceType = getDeviceType($e), rtmp_app = $e.find("name").text(), info = getStreamInfo(rtmp_app);
				create$ffmpegUi(info.deviceTypeName, checkeds, "play", info.name).appendTo("#playbackContainer");
				if (!checkeds[keyFromNames(info.deviceTypeName, "play", info.name)]) {
					renewFFmpeg(_op["playback_" + deviceType], keyFromNames(info.deviceTypeName, "play", info.name), 'rtmp://' + rtmp_hostname + '/rtmp/' + rtmp_app, "#video-chat-panel");
				}
			});
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button ui-right' title='Refresh Audio/Video Streams'></span>").appendTo("#playbackContainer").click(listStreams);
		}, function (error) {
			var err = error;
		});
	};
	listDevices();
	listStreams();
}

function getMyName() { return $('#enter-your-name').val(); }

function getRtmpAppName(deviceTypeName) { return getMyName() + '|' + deviceTypeName; }

function getStreamInfo(rtmpAppName) { var tmp = rtmpAppName.split("|"); return { name: tmp[0], deviceTypeName: tmp[1] }; }

function restoreDirectShowDevice(deviceType, $dropdown, rtmp_hostname) {
	var key = "capture-my-" + deviceType, device = devices[key], val;
	if (device) {
		if ($dropdown.find("option").filter(function () { return this.value === device; }).length > 0) {
			$dropdown.val(device);
		}
		val = $dropdown.val();
		if (val) {
			if (device !== val)
				renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + getRtmpAppName(deviceType));
		} else {
			removeFFmpeg(key);
		}
	} else if (val = $dropdown.val()) {
		renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + getRtmpAppName(deviceType));
	}
	return val || "";
}

function setDirectShowDevice(deviceType, val, rtmp_hostname) {
	var key = "capture-my-" + deviceType, device = devices[key];
	if (val) {
		if (device !== val)
			renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + getRtmpAppName(deviceType));
	} else if (device) {
		removeFFmpeg(key);
	}
	return val || "";
}

function updateDirectShowDeviceUi(deviceTypeName, device) {
	var $checkbox = $("#capture-my-" + deviceTypeName).prop("disabled", !device);
	if (!device)
		$checkbox.prop("checked", false);
	var $label = $("label[for=capture-my-" + deviceTypeName + "]");
	$label/*.add($label.find("*"))*/.attr("title", device);
}

// start the loop				
animate();

function animate() {
	requestAnimationFrame( animate );
	render();
}

function render() {
	for (var key in videos) {
		if (ffmpeg_ids[key] && (_applet.getSN || typeof(_applet.getSN) === "unknown")) {
			var sn_ = _applet.getSN(ffmpeg_ids[key]);
			if ( sn_ != sn && sn_ > 0 ) {
				sn = sn_;
				var dataURI = _applet.getDataURI(ffmpeg_ids[key]);
				// drop frames accumulated in the queue
/*
				while (_applet.getSN(ffmpeg_ids[key]) > sn) {
					console.log("dropped frame # " + sn);
					sn = _applet.getSN(ffmpeg_ids[key]);
					dataURI = _applet.getDataURI(ffmpeg_ids[key]);
				}
*/ // we do it in the applet now when drop-unused-frames="yes"
				// assign image src
				videos[key].drawUri(dataURI);
			}
		}
	}
}
</script>

</body>
</html>
