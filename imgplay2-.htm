<!doctype html>
<html>
<head>
<title>imgplay2-</title>
<link rel="stylesheet" href="//code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="//code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script>
/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
if ( !window.requestAnimationFrame ) {
	window.requestAnimationFrame = (function() {
		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
			window.setTimeout( callback, 1000 / 60 );
		};
	})();
}
</script>
<style>
	.ui-resizable-handle { cursor: nw-resize; }
	.ui-button { /*float: right;*/ display: inline-block; cursor: pointer; /*margin-bottom: -3px;*/ vertical-align: top; float: right; }
	input[type=checkbox] { width: 8px; height: 8px; }
	.roundCheckbox input[type=checkbox] { width: 3px; height: 3px; visibility: hidden; margin: 0; }
	.roundCheckbox {
		display: inline-block;
		vertical-align: -4px;
		
		width: 12px;
		height: 12px;
		background: #ddd;
		/*margin: 20px 90px;*/
		margin-bottom: -2px;

		border-radius: 100%;
		position: relative;
		-webkit-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow: 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox label {
		display: block;
		width: 9px;
		height: 9px;
		border-radius: 100px;

		-webkit-transition: all .5s ease;
		-moz-transition: all .5s ease;
		-o-transition: all .5s ease;
		-ms-transition: all .5s ease;
		transition: all .5s ease;
		cursor: pointer;
		position: absolute;
		top: 2px;
		left: 2px;
		/*z-index: 1;*/

		background: #333;

		-webkit-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		-moz-box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
		box-shadow:inset 0px 1px 3px rgba(0,0,0,0.5);
	}
	.roundCheckbox input[type=checkbox]:checked + label {
		background: #26ca28;
	}
	.roundCheckbox input[type=checkbox]:disabled + label {
		background: #bbb;
		cursor: default;
	}
	body { color: #508; }
</style>
</head>
<body onload="registerAppletStateHandler()">
<object id="img-applet-ie"
  classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93"
  width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;">
  <param name="archive" value="img-applet.jar">
  <param name="code" value="img_applet.ImgApplet">
  <param name="java_status_events" value="true">
  <param name="debug" value="yes">
  <comment>
    <embed id="img-applet"
      type="application/x-java-applet"
      width="100" height="40" style="position:absolute;left:-1000px;top:-1000px;" 
      archive="img-applet.jar"
      code="img_applet.ImgApplet"
      pluginspage="http://java.com/download/"
      java_status_events="true"
      debug="yes" />
  </comment>
</object>
<div id="deviceContainer"></div>
<div id="playbackContainer"></div>
<div id="videoContainer"></div>
<script>

// global variables
var applets = [ document.getElementById( 'img-applet' ), document.getElementById( 'img-applet-ie' ) ],
	_applet,
	videoCanvas = createVideoCanvas(document.getElementById( 'videoContainer' ), true),
	sn = 0,
	ffmpeg_ids = {},
	devices = {};

function checkAppletMethod(applet, method) { return applet && (!method || (applet[method] || typeof(applet[method]) === "unknown")); }

function checkApplet(applet, applet_ie, method) { if (!_applet) { if (applet && applet.createFFmpeg) { _applet = applet; } else if (applet_ie && typeof(applet_ie.createFFmpeg) === "unknown") { _applet = applet_ie; } } return checkAppletMethod(_applet, method); }

function registerAppletStateHandler() {
	var READY = 2;
	// register onLoad handler if applet has not loaded yet
	if (checkApplet(applets[0], applets[1])) {
		if (_applet.status < READY)  {
			_applet.onload = onLoadHandler;
		} else if (_applet.status >= READY) {
			// applet has already loaded or there was an error
			onLoadHandler();
		}
	}
}

function createVideoCanvas (container, resizable) {
	var image, videoImage, $videoImageContainer, videoImageContext, last_img = -1;
	function createImage() { return $('<img style="visibility: hidden; display: none;" />').appendTo(container)[0]; }
	image = [ createImage(), createImage() ];
	if (resizable)
		$videoImageContainer = $("<div></div>").appendTo(container);
	videoImage = $("<canvas></canvas>").appendTo($videoImageContainer || container)[0];
	// create '2d' context; background color if no video present
	videoImageContext = videoImage.getContext( '2d' );
	videoImageContext.fillStyle = '#005337';
	videoImageContext.fillRect( 0, 0, videoImage.width, videoImage.height );				
	// assign image elements onload handler
	var setDimensions = true, curImageIndex;
	image[0].onload = image[1].onload = function() {
		if (setDimensions) {
			setDimensions = false;
			videoImage.width = this.width;
			videoImage.height = this.height;
			if ($videoImageContainer) {
				$videoImageContainer.width(this.width);
				$videoImageContainer.height(this.height);
			}
			if (resizable)
				$videoImageContainer.draggable().resizable({
					aspectRatio: this.width / this.height,
					resize: function(event, ui) {
						image[0].width = image[1].width = videoImage.width = ui.size.width;
						image[0].height = image[1].height = videoImage.height = ui.size.height;
						videoImageContext.drawImage( image[curImageIndex], 0, 0, videoImage.width, videoImage.height );
					}
				});
		}
		curImageIndex = this === image[0] ? 0 : 1;
		videoImageContext.drawImage( this, 0, 0, videoImage.width, videoImage.height );
	};
	return {
		drawUri:	function (uri) { image[last_img = (last_img + 1) % 2].src = uri; },
		destroy:	function () { (container.empty || $(container).empty)(); }
	};
}

function checkboxClick(checkbox) {
	_applet[checkbox.checked?'play':'stopPlayback'](ffmpeg_ids[checkbox.id]);
}
function findByFFmpegId(ffmpeg_id) {
	for (var key in ffmpeg_ids)
		if (ffmpeg_ids[key] === ffmpeg_id)
			return key;
}
function checkboxCallback(ffmpeg_id, playing) {
	var key = findByFFmpegId(ffmpeg_id);
	if (key)
		document.getElementById(key).checked = playing;
}

function removeFFmpeg(key) {
	if (ffmpeg_ids[key]) {
		_applet.stopPlayback(ffmpeg_ids[key]);
		_applet.removeFFmpegById(ffmpeg_ids[key]);
		delete ffmpeg_ids[key];
		delete devices[key];
	}
}

function recreateFFmpeg(key, callback, param_arr) {
	var playing = false;
	if (ffmpeg_ids[key]) {
		playing = _applet.isPlaying(ffmpeg_ids[key]);
		removeFFmpeg(key);
	}
	ffmpeg_ids[key] = _applet.createFFmpegId(callback, param_arr);
	if (playing)
		_applet.play(ffmpeg_ids[key]);
}

var _op = { capture_video: 1, playback_video: 2, capture_audio: 3, create_audio: 4, list_devices: 5, list_options: 6 };

function renewFFmpeg(op, key, p1, p2) {
	switch (op) {

	case _op.capture_video: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-r', '25',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'video=' + p1,		// video device, e.g. "Logitech QuickCam E3500"
			'ffmpeg-c:v', 'libx264',
			'ffmpeg-preset', 'ultrafast',
			'ffmpeg-tune', 'zerolatency',
			'ffmpeg-pix_fmt', 'yuv420p',
			'ffmpeg-g', '50',
			'ffmpeg-an', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v"
			//'debug', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_video: recreateFFmpeg( key, 'checkboxCallback', [
			//"ffmpeg-re", "",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/v",
			//"ffmpeg-i", "rtmp://europaplus.cdnvideo.ru:1935/europaplus-live/eptv_main.sdp",
			//"ffmpeg-i", "rtmp://85.132.78.6:1935/live/muztv.stream",
			//"ffmpeg-i", "http://83.139.104.101/Content/HLS/Live/Channel(Sk_1)/index.m3u8",
			//"ffmpeg-map", "0:6",
			"ffmpeg-c:v", "mjpeg",
			"ffmpeg-q:v", "0.0",
 /* ‘-vsync parameter’
    Video sync method. For compatibility reasons old values can be specified as numbers. 
    Newly added values will have to be specified as strings always.
    ‘0, passthrough’ - Each frame is passed with its timestamp from the demuxer to the muxer. 
    ‘1, cfr’ - Frames will be duplicated and dropped to achieve exactly the requested constant frame rate. 
    ‘2, vfr’ - Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp. 
    ‘drop’ - As passthrough but destroys all timestamps, making the muxer generate fresh timestamps based on frame-rate. 
    ‘-1, auto’ - Chooses between 1 and 2 depending on muxer capabilities. This is the default method.
  */
			"ffmpeg-vsync", "0",
			"ffmpeg-f:o", "mjpeg",
			"ffmpeg-an", "",
			//"ffmpeg-muxpreload", "10",
			//"ffmpeg-muxdelay", "10",
			//"ffmpeg-loglevel", "warning",
			"drop-unused-frames", "yes",
			"debug", "yes",
		] ); break;

	case _op.capture_audio: recreateFFmpeg( key, 'checkboxCallback', [
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-audio_buffer_size', '50',
			'ffmpeg-i', 'audio=' + p1,		// audio device, e.g. "Microphone (USB Audio Device)"
			'ffmpeg-c:a', 'libmp3lame',
			'ffmpeg-async', '1',
			'ffmpeg-vn', '',
			'ffmpeg-f:o', 'flv',
			'ffmpeg-o', p2,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			//'debug', 'yes',
		] ); devices[key] = p1; break;

	case _op.playback_audio: recreateFFmpeg( key, 'checkboxCallback', [
			"ffmpeg-re", "no",
			"ffmpeg-analyzeduration", "1000",
			"ffmpeg-rtmp_buffer", "0",
			"ffmpeg-rtmp_live", "live",
			//"ffmpeg-f:i", "",
			"ffmpeg-i", p1,			// rtmp url, e.g. "rtmp://10.44.43.244/rtmp/a"
			//"ffmpeg-c:a", "libmp3lame",
			//"ffmpeg-f:o", "mp3",
			//"mp3-frames-per-chunk", "1",
			"ffmpeg-f:o", "wav",
			"ffmpeg-vn", "",
			//"debug", "yes",
		] ); break;
	}
}

function callFFmpeg(op, p1) {
	var _ffmpeg_id, defer = $.Deferred().always(function () {
		if (_ffmpeg_id) {
			_applet.removeFFmpegById(_ffmpeg_id);
			//alert("remove: " + _ffmpeg_id);
		}
	});
	window.dataCallback = function (ffmpeg_id, playing) {
		if (!playing) {
			defer.resolve(_applet.getStderrData(ffmpeg_id));
			//alert("resolve: " + ffmpeg_id);
		}
	};
	switch (op) {

	case _op.list_devices: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_devices', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', 'dummy',
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;

	case _op.list_options: _ffmpeg_id = _applet.createFFmpegId( 'dataCallback', [
			'ffmpeg-list_options', 'true',
			'ffmpeg-f:i', 'dshow',
			'ffmpeg-i', p1,			// device, e.g. 'video=Logitech QuickCam Communicate STX', or 'audio=Logitech Mic (Communicate STX)'
			'ffmpeg-o', '',
			'debug', 'yes',
		] ); break;
	}
	if (_ffmpeg_id) {
		_applet.play(_ffmpeg_id);
	}
	return defer.promise();
}

function onLoadHandler() {
	// event handler for ready state
	var rtmp_hostname = window.location.hash && window.location.hash.length > 7 ? window.location.hash.substring(1) : window.location.hostname;
	// FFmpeg UI functions
	function keyFromName(opName, name, deviceType) { return (opName || "capture") + "-" + (name || "my") + "-" + deviceType; }
	function create$FFmpegUi(deviceType, first, opName, name) {
		var id = keyFromName(opName, name, deviceType);
		return $((first ? '<span>' + (opName || "capture") + ': </span>' : '<span>  </span>') +
			'<label for="' + id + '">' + (name ? "<bold>" + name + "</bold>'s " : "") + deviceType + '</label>' +
			'<div class="roundCheckbox">' +
			'<input id="' + id + '" type="checkbox" onclick="checkboxClick(this)"' + ($("#" + id).is(":checked") ? ' checked="checked"' : '') + ' />' +
			'<label for="' + id + '"></label>' +
			'</div>');
	}
	function updateDeviceUi(deviceType, device) {
		var $checkbox = $("#capture-my-" + deviceType).prop("disabled", !device);
		if (!device)
			$checkbox.prop("checked", false);
		$("label[for=capture-my-" + deviceType + "]").attr("title", device);
	}
	var listDevices = function () {
		$("#deviceContainer select").css("visibility", "hidden");
		callFFmpeg(_op.list_devices).then(function (res) {
			// parse output
			var re = /\[\s*dshow\s*@\s*[a-fA-F0-9]+\s*\]\s*"?(.*?)"?\s*\r?\n/ig;
			var tmp, arr = []; // , out = "";
			while ((tmp = re.exec(res)) !== null) {
				//out += "\r\n" + tmp[1];
				arr.push(tmp[1]);
			}
			//document.getElementById("list-devices").innerHTML = out;
			// recreate dropdowns
			$("#deviceContainer").empty();
			re = /^\s*Direct\s*Show\s*(video|audio)\s*devices\s*$/i;
			var re1 = /^\s*Could\s*not\s*enumerate\s*(video|audio)\s*devices\.?\s*$/i;
			var $select, $selects = [], deviceTypes = [];
			for (var i in arr) {
				if (re.test(arr[i])) {
					var deviceType = re.exec(arr[i])[1].toLowerCase();
					create$FFmpegUi(deviceType, $selects.length == 0).appendTo("#deviceContainer");
					$selects.push($select = $("<select style='border-width:0;'></select>").appendTo("#deviceContainer").change(function () {
						updateDeviceUi(deviceType, setDevice(deviceType, $(this).val(), rtmp_hostname));
					}));
					deviceTypes.push(deviceType);
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo($select);
					first = false;
				} else if (re1.test(arr[i])) {
					$("<option></option>").attr({ "value": "", "disabled": "disabled" }).text(arr[i]).appendTo($select);
				} else {
					$("<option></option>").attr("value", arr[i]).text(arr[i]).appendTo($select);
				}
			}
			// try to restore current devices
			for (var i = 0; i < $selects.length; i++) {
				updateDeviceUi(deviceTypes[i], restoreDevice(deviceTypes[i], $selects[i], rtmp_hostname));
				if ($selects[i].find("option").filter(function () { return this.value; }).length < 2)
					$selects[i].css("display", "none");
			}
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button' title='Refresh Audio/Video Devices'></span>").appendTo("#deviceContainer").click(listDevices);
		});
	}, listStreams = function () {
		$.ajax({ url: 'http://' + rtmp_hostname + '/rtmp/stat', dataType: "xml" }).then(function (data) {
			var $xml = $(data), $streams = $xml.find("rtmp > server > application:has(> name)").filter(function () { return $(this).find("> name").text() === "rtmp"; }).find("> live > stream");
			function getDeviceType($stream) {
				var $video = $stream.find("> meta > video"), $audio;
				return parseFloat($video.find("> width").text()) > 0 && parseFloat($video.find("> height").text()) > 0 ? "video" :
					$stream.find("> meta > audio").has("*") ? "audio" : "unknown";
			}
			$("#playbackContainer").empty();
			$streams.each(function (i, e) {
				var $e = $(e), deviceType = getDeviceType($e), opName = "play", name = $e.find("name").text();
				create$FFmpegUi(deviceType, i == 0, opName, name).appendTo("#playbackContainer");
				renewFFmpeg(_op["playback_" + deviceType], keyFromName(opName, name, deviceType), 'rtmp://' + rtmp_hostname + '/rtmp/' + name);
			});
			// add refresh button
			$("<span class='ui-icon ui-icon-refresh ui-button' title='Refresh Audio/Video Streams'></span>").appendTo("#playbackContainer").click(listStreams);
		}, function (error) {
			var err = error;
		});
	};
	listDevices();
	listStreams();
}

function rtmp_app(deviceType) { return deviceType === "video" ? "v" : deviceType === "audio" ? "a" :  "u"; }

function restoreDevice(deviceType, $dropdown, rtmp_hostname) {
	var key = "capture-my-" + deviceType, device = devices[key], val;
	if (device) {
		if ($dropdown.find("option").filter(function () { return this.value === device; }).length > 0) {
			$dropdown.val(device);
		}
		val = $dropdown.val();
		if (val) {
			if (device !== val)
				renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + rtmp_app(deviceType));
		} else {
			removeFFmpeg(key);
		}
	} else if (val = $dropdown.val()) {
		renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + rtmp_app(deviceType));
	}
	return val || "";
}

function setDevice(deviceType, val, rtmp_hostname) {
	var key = "capture-my-" + deviceType, device = devices[key];
	if (val) {
		if (device !== val)
			renewFFmpeg(_op["capture_" + deviceType], key, val, 'rtmp://' + rtmp_hostname + '/rtmp/' + rtmp_app(deviceType));
	} else if (device) {
		removeFFmpeg(key);
	}
	return val || "";
}

// start the loop				
animate();

function animate() {
	requestAnimationFrame( animate );
	render();
}

function render() {
	if (ffmpeg_ids["playback-my-video"]) {
		var sn_ = _applet.getSN(ffmpeg_ids["playback-my-video"]);
		if ( sn_ != sn && sn_ > 0 ) {
			sn = sn_;
			var dataURI = _applet.getDataURI(ffmpeg_ids["playback-my-video"]);
			// drop frames accumulated in the queue
/*
			while (_applet.getSN(ffmpeg_ids["playback-my-video"]) > sn) {
				console.log("dropped frame # " + sn);
				sn = _applet.getSN(ffmpeg_ids["playback-my-video"]);
				dataURI = _applet.getDataURI(ffmpeg_ids["playback-my-video"]);
			}
*/ // we do it in the applet now when drop-unused-frames="yes"
			// assign image src
			videoCanvas.drawUri(dataURI);
		}
	}
}
</script>

</body>
</html>
